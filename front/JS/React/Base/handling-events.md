# 事件处理

目录

- [语法](#语法)
- [向事件处理程序传递参数](#向事件处理程序传递参数)

## 语法

- React 事件绑定属性的命名采用驼峰式写法，而不是小写。
- 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串( DOM 素的写法)。
- 不能使用返回 false 的方式阻止默认行为。
- 需要绑定 this，在 constructor 使用 bind，在 class 中使用 ()=>{},再或者在事件定义上使用前面的两种方法均可。

```
// 函数定义
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}
```

```
// 类定义
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为函数绑定 this
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);
```

```
// 函数绑定 this 替代方法
class LoggingButton extends React.Component {

  // 箭头函数，不改变 this 指向
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

## 向事件处理程序传递参数

- 在事件定义上，使用 bind 或 ()=>{} 传参。
- 事件对象会默认为最后一个参数传入。
- 由于放在 render 中，每次渲染都会重新生成事件处理函数。

```
class Popper extends React.Component{
    constructor(){
        super();
        this.state = {name:'Hello world!'};
    }
    
    preventPop(name, e){    //事件对象e要放在最后
        e.preventDefault();
        alert(name);
    }
    
    render(){
        return (
            <div>
                <p>hello</p>
                <a href="https://reactjs.org" onClick={this.preventPop.bind(this,this.state.name)}>Click</a>
            </div>
        );
    }
}
```